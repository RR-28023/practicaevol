---
title: 'Entrega 2: Elaboración de horarios mediante algoritmos evolutivos'
author: "Juan Miguel Frau y Ramon Rotaeche"
date: "28/12/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1.Enunciado

El objetivo de esta entrega es implementar un algoritmo evolutivo para la elaboración de  horarios  en  un  centro  educativo. Para ello:

a) Estableced cuáles son las restricciones soft y hard de vuestro algoritmo y justificadlas.

b) Explicad claramente cuál es la codificación usada, cuáles son los parámetros del algoritmo y su función de fitness. Justificad su elección.

c) Cread varias entradas con distintos grados de dificultad y analizad los resultados obtenidos.Podéis utilizar como entrada listas de asignaturas y sus horas semanales de distintos cursos de secundaria y bachillerato.

d) Proponed alguna modificación al algoritmo y analizad los resultados obtenidos. Esta modificación puede ser un nuevo operador de mutación o recombinación,una nueva estrategia de selección de los individuos de la nueva generaciónm, etc.


## 2. Codificación empleada

### 2.1 Información de entrada
[TBC: explicar archivo excel y las dataframes que se generan]

- Se supone que todas las clases son de una hora, yq ue no hay recreos

### 2.2 Codificación de la información de entrada

Con la información introducida a través del archivo excel, nuestro programa genera los siguientes elementos:

* *clases* = *['Clase A', 'Clase B', ..., Clase m]*, es una lista de m elementos conteniendo el id de cada clase. Cuando en la notación nos referimos a una clase usando un número *x*, nos referimos a la clase que ocupa el lugar x-ésimo en esta lista.

* *asignaturas* = *['Matemáticas', 'Lengua', ..., Asignatura n]*, es una lista de n elementos conteniendo el id de cada asignatura. Cuando en la notación nos referimos a una asignatura usando un número *x*, nos referimos a la clase que ocupa el lugar *x-ésimo* en esta lista.

* *profesores* = *['Pepe', 'Pepa', ..., Profesor p]*, es una lista de p elementos conteniendo el id de cada profesor. Cuando en la notación nos referimos a un profesor usando un número *x*, nos referimos al profesor que ocupa el lugar *x-ésimo* en esta lista.

* *franjas* = *['Lunes 9.00 - 10.00', Franja t]*, es una lista de t elementos con todas las franjas de una hora que componen el horario lectivo, ordenadas de forma que en primer lugar está la primera hora lectiva del lunes y en último lugar está la última hora del viernes. Cuando en la notación nos referimos a una franja usando un número *x*, nos referimos a la franja que ocupa el lugar *x-ésimo* en esta lista. Por ejemplo, si el horario es todos los días de la semana de 9.00 a 14.00, la franja horaria *5* corresponde al lunes de 13.00 a 14.00, mientras que la franja *6* corresponde al martes de 9.00 a 10.00.

* *Horas_Clase_Asignatura~mxn~*, abreviado como **HCA~mxn~**, es una matriz donde el elemento *ij* es el número de horas asignadas a la clase *i* de la asignatura *j* (*HCA~ij~* valdrá 0 cuando la clase *i* no tenga asignada ninguna hora de la asignatura *j*)

* *Profesor_Clase_Asignatura~mxn~*, abreviado como **PCA~mxn~**, es una matriz donde el elemento *ij* es el profesor que da la asignatura *j* a la clase *i*. Esto es necesario porque una misma asignatura (ej. Lengua) puede ser impartida por los diferentes profesores a diferentes clases (*PCA~ij~* valdrá 0 cuando la clase *i* no tenga asignada la asignatura *j*)

* *Disponibilidad_Profesor_Franja~pxt~*, abreviado como **DPF~pxt~**, es una matriz donde el elemento *ij* representa la disponibilidad del profesor *i* en la franja *j*. Vale 1 si el profesor puede dar clase a esa hora o 0 si no puede.


### 2.3 Genotipo

Para representar una posible solución usaremos la matriz **Genotipo~mxt~**, donde el elemento *ij* representa la asignatura asignada a la clase *i* en la franja *j*.

Nótese que la solución no especifica qué profesor es asignado para dar una determinada asignatura a una determinada clase. Esto es porque vamos a diseñar el algoritmo de modo que al generar una posible solución, el profesor asignado a cada clase-asignatura sea el correcto. Al fin y al cabo esto es una condición *hard* que hay que cumplir, y permite simplificar la notación y reducir el tamaño del espacio de búsqueda. 

Asociada a la matriz **Genotipo~mxt~**, en el código también se crea la matriz **Asignatura_Profesor_Franja~pxt~**, abreviado como **APF~pxt~**, en la que el elemento *ij* representa la asignatura asignada al profesor *i* en la franja *j*. Si no hay asignatura asignada, *ij* valdrá 0. Si hay más de una asignatura asignada al profesor *i* en la franja *j*, *ij* valdrá -1. Esta matriz no añade información adicional y se deduce enteramente de la matriz **Genotipo~mxt~**, pero se crea por conveniencia para simplificar ciertos cálculos. 

### 2.4 Función de fitness

La función de fitness implementada comprobará si las restricciones hard y soft mencionadas anteriormente se cumplen o no. Para ello, estarán disponibles dos contadores, uno para las restricciones hard y otro para las soft, donde en cada violación de una restricción su respectivo contador se verá incrementado. El coste del individuo será la suma de ambos contadores, sin embargo, dichos contadores serán multiplicados por unos pesos para poder simular que las restricciones hard tienen una importancia superior que las soft.

Dicho esto, cuantas más restricciones infrinja, más grande será su valor de fitness, por lo que nos interesará encontrar el individuo con un valor de fitness mínimo, es decir, que será el que menos restricciones infringe.


## 3. Restricciones

Las restricciones "hard" del algoritmo son las siguientes:

1. No se pueden asignar horas a un profesor fuera de su disponibilidad. Por motivos de conciliación laboral esta restricción debe estar presente y se comprobará comparando con un horario que ha estimado cada profesor. Estos horarios de disponibilidad se encuentran en los inputs tal como se ha visto anteriormente.

1. No se pueden asignar dos asignaturas a la vez a la misma clase. Esta restricción vendrá implícita en la codificación de los individuos ya que en cada franja únicamente se asigna una única asignatura, por lo que no será necesario que se tenga en cuenta para ser evaluada.

1. No se pueden asignar dos clases a la vez al mismo profesor. Esta restricción se deberá tener en cuenta en la evaluación de cada individuo.

1. Se deben asignar el número de horas exacto de las asignaturas a cada clase, ni más ni menos horas. Esta restricción no es necesario que se tenga en cuenta para ser evaluada debido a que esta se cumple a la hora de crear cada uno de los genotipos.

1. Las asignaturas se deben asignar al profesor definido en los inputs aunque haya otros profesores que impartan esa asignatura a otra clase. Esta restricción, tal como se ha explicado anteiormente, vendá implícita en la codificación del genotipo gracias a la matriz *Profesor_Clase_Asignatura~mxn~* implementada.

1. Las clases no pueden tener horas vacías entre medias pero si pueden tener horas vacías al principio y al final de la jornada si el número de horas semanales de esa clase es inferior al número total de horas disponibles.

1. Únicamente se podrá dar clase dentro del horario establecido. Esta restricción se satisfacerá ya que en la codificación de los individuos ya vienen establacidas dichas franjas horarias, por lo que únicamente se podrán asignar horas de asignaturas dentro de las franjas establecidas.


Las restricciones "soft" del algoritmo son las siguientes:

1. Los profesores deben tener el menor número de huecos (horas vacías entre medias) posible. 

1. El número de horas impartidas por un profesor deben distribuirse lo más uniformemente posible a lo largo de la semana. Por ejemplo, si un profesor tiene que dar en total 10 horas, es preferible que dé 2 horas cada día a que dé 5 horas en dos días.

1. El número total de periodos vacíos se debe distribuir uniformemente entre los profesores. PROPONGO CARGARNOS ESTA (QUE ES DIFICIL) Y EN SU LUGAR PONER: Si una clase tiene menos horas asignadas que horas hay en el horario lectivo, los espacios sin asignaturas deben estar lo más concentrados posible. Por ejemplo, si la semana lectiva son 25 horas (5 por día) y una clase tiene 20 horas asignadas, es preferible que tengan un día de la semana completamente libre a que tengan una hora libre cada día.

1. Las clases no deben tener la misma asignatura más de una vez en el día.

1. ESTA LA PUSE YO PERO CREO QUE ES IGUAL QUE LA ANTERIOR, NO? El número de horas de una clase determinada debe repartirse lo más uniformemente posible (esto aplica en los casos en los que el número de horas semanales de la clase es inferior al número total de horas disponibles).

## 4. Algoritmo

El algoritmo se estructura de la siguiente manera [COMPLETAR cuando lo tengamos]

```
def ejecutar_algoritmo(n_iter, tam_pop):
    '''
    Función principal para ejecutar todos los pasos e iteraciones del algoritmo evolutivo. No devuelve ningún objeto.
    :param n_iter: número de iteraciones
    :param tam_pop: tamaño de la población
    '''
    inputs = codificar_inputs()
    poblacion = inicializar_poblacion(inputs, tam_pop)
    for i in range(n_iter):
        padres = seleccionar_padres(poblacion, tam_pop)
        recombinar_padres()
        mutar_individuos()
        poblacion = seleccionar_supervivientes(poblacion, tam_pop)
    solucion = seleccionar_solucion(poblacion)
    solucion.plot_genotipo()
```

### 4.1 Inicialización de los genotipos

El procedimiento que empleamos para inicializar un genotipo de forma aleatoria es:

Mientras quede alguna hora de alguna asignatura por asignar a una clase:
  Para cada clase *i*:
    Para cada asignatura j:
      Si el número de horas pendientes de asignar a la clase *i* de la asignatura *j* es > 0:
        1. Escoger un número de franja al azar entre las franjas disponibles para la clase *i*.
        2. Asignar la asignatura *j* a esa franja horaria
        3. Eliminar la franja seleccionada de la lista de franjas disponibles para la clase *i*.
        4. Restar 1 al número de horas pendientes de asignar a la clase *i* de la asignatura *j*.


### 4.2 Función de fitness

A continuación, se puede observar el código implementado para el cálculo del valor de fitness de un individuo donde se recorre todo la matriz que conforma el genotipo buscando las restricciones establecidas. Así pues, las restricciones anteriormente mencionadas que serán evaluadas en la función de fitness serán:

* Restricciones hard 1, 3 y 6.
* Restricciones soft 1, 2, 3, 4 y 5.

```
Insertar código
```

### 4.3 Selección de padres

Para realizar la selección de padres se ha llevado a cabo el método de selección por torneo. Para ello, se han desordenado los individuos para añadir aletoriedad a la selección y se han formado *n* grupos formados por *k* individuos. De cada grupo, se ha seleccionado como padre el individuo que tiene menor valor de fitness.


```
Insertar código
```

### 4.4 Recombinación

Para realizar la recombinación, se toman dos individuos (*Padre 1* y *Padre 2*) y, siendo *n* el número total de clases, se seleccionan aleatoriamente *n/2* clases del *Padre 1* (*n/2 - 0.5* si *n* es impar) y las *n/2* clases complementarias del *Padre 2* (*n/2 + 0.5* si *n* es impar) combinándolas en un nuevo individuo, el *Hijo 1*. Por otro lado, las clases no seleccionadas de *Padre 1* y *Padre 2* se combinan para generar otro individuo adicional, el *Hijo 2*.

Por ejemplo, si hay cuatro clases ('Clase A', 'Clase B', Clase C' y 'Clase D'). Una combinación posible sería formar el *Hijo 1* con la 'Clase A' y la 'Clase D' del *Padre 1*, y la 'Clase B' y la 'Clase C' del *Padre 2*. Mientras que el *Hijo 2* estaría formado por la 'Clase B' y la 'Clase C' del *Padre 1*, y la Clase A' y la 'Clase D' del *Padre 2*. 

```
Insertar código
```

### 4.5 Mutación

La mutación consistirá en permutar dos franjas horarias del horario. Sin embargo, debido a las restricciones realizadas y la codificación inicial especificada, no será posible permutar a nivel de genotipo, sino que se realizará en una de las clases para evitar que una clase tenga una asignatura que no le pertenece. Por ello, en primer lugar, se obtendrá una clase de forma aleatoria y, seguidamente, se elegirán dos franjas del horario de dicha clase de forma aleatoria y se intercambiarán la posición.


```
Insertar código
```

### 4.6 Selección de supervivientes

Para realizar la selección de supervivientes en la población de individuos se ha utilizado el método de la ruleta.
El método de la ruleta consiste en dotar a cada individuo de una probabilidad proporcional a su valor de fitness donde el indiviuo con mejor valor de fitness, que será el individuo que tenga el valor mínimo, tendrá más probabilidades de ser elegido. Una vez establecidas las probabilidades se realizarán *n* tiradas a la ruleta, donde *n* será el tamaño de la población estimada al inicio, y se obtendrán los supervivientes elegidos de forma aleatoria.

```
Insertar código
```

### Salidas del algoritmo

El algoritmo implementado ofrece de forma visual el fitness del mejor superviviento de cada iteración para poder seguir el proceso.

FALTA PONER IMAGEN

Ofrece, una vez finalizado, el número de veces qu el inididuo final infringe cada una de las restricciones tanto hard como soft.

FALTA PONER IMAGEN

Y, finalmente, se ofrece de forma visual el horario de cada una de las clases y de cada uno de los profesores. Esto se muestra para el mejor indivduo inicial y el individuo final para poder comparar los cambios sucedidos durante el algoritmo.

FALTA PONER IMAGEN


## 5. Pruebas realizadas

Para testear el algoritmo se han utilizado diferentes entradas las cuales se ha ido incrementando en cada una de ellas su dificultad para el algoritmo. Dichas pruebas se han llevado a cabo con un tamaño de la población igual a 500 y con un máximo de 1000 iteraciones. Además, se ha estimado que el número de padres que se elegirán será 1/5 de la población total.

Finalmente, añadir que estos son solo algunas de las entradas creadas dentro de la gran posibilidad de entardas que existen, por ello, destacar que un pequeño cambio en este conjunto de datos de entrada puede conllevar grandes cambios en el algoritmo, y consecuentemente resultados totalmente diferentes.

### 5.1 Entrada 1

El primer conjunto de inputs utilizado está compuesto por:

* 11 profesores que únicamente dan una asignatura, una diferente cada uno
* 4 grupos de clase con el mismo número de horas de clase cada uno
* 12 asignaturas
* Todos los profesores tienen una disponibilidad horaria en todas la horas
* El horario lectivo es de 8h a 14h toda la semana


El resultado obtenido es de un valor de fitness de X. En este caso, no se ha infringido ninguna restricción hard pero si han infringido algunas restricicones soft, X veces la restrccion soft X y X veces la restriccion soft X, propiciando el valor de fitness obtenido.

En cuanto a la gráfica (imagen X), se puede apreciar en las primeras iteraciones un descenso rápido en el valor de fitness que se va atenuando siendo más constante a medida que avanzan las iteraciones.

En cuanto a la comparativa entre el mejor individuo de la población inicial y el indivudo final (imagen x), se puede ver como han desaparecido los huecos sin clase y se han eliminado en mayor parte la repetición de una misma asignatura el mismo día.

Sobre la imagen X que compara los horarios de los profesores entre el mejor individuo de la población inicial y el indivudo final, ver como se ha conseguido evitar el solapamiento, se ha conseguido que el profesor dé todas sus clases de forma seguida y que el número de horas de clase sea uniforme durante todos los días de la semana.

FALTA PONER IMÁGENES Y RESULTADOS

### 5.2 Entrada 2

El segundo conjunto de inputs utilizado es prácticamente igual al anterior con la única diferencia de que en este caso los profesores no tienen un disponibilidad horaria completo por lo que habrá días en los que no podrán ejercer.

El resultado obtenido ha sido de un valor de fitness de X. En este caso, no se ha infringido ninguna restricción hard pero si han infringido algunas restricicones soft, X veces la restrccion soft X y X veces la restriccion soft X, propiciando el valor de fitness obtenido.

Ver en las imágenes X y X como, además de todas las mejoras vistas en la entrada anterior respecto al primer indiduo y el individuo final, también se puede apreciar como los días marcados en verde, los cuales indican que el profesor no tiene disponibilidad, no se han asignado ninguna hora de clase ese día. 

FALTA PONER IMÁGENES Y RESULTADOS

### 5.3 Entrada 3

El tercer conjunto de inputs utilizado está compuesto por:

* 5 profesores que pueden dar diferentes asignaturas a diferentes clases
* 4 grupos de clase con el mismo número de horas de clase cada uno
* 12 asignaturas
* Los profesores hay días en los que no tienen disponibilidad
* El horario lectivo es de 8h a 14h toda la semana

El valor de fitness obtenido ha sido de X. Este caso, no ha tenido ninguna violación de las restricciones hard pero si alguna de las restricciones soft.

Además, indicar, tal como se ve en la imagen X, como al ser menos profesores que la entradas anteriores se ha tenido que ajustar en gran medida los horarios de los profesores pero siempre respetando los dias que no tienen disponibilidad.

FALTA PONER IMÁGENES Y RESULTADOS

### 5.4 Entrada 4

El cuarto conjunto de inputs utilizado está compuesto por:

* 11 profesores que pueden dar diferentes asignaturas a diferentes clases
* 4 grupos de clase con diferente número de horas de clase cada uno
* 12 asignaturas
* Los profesores hay días en los que no tienen disponibilidad
* El horario lectivo es de 8-14h el lunes, de 8-15h los martes, miércoles y jueves y de 8-13h los viernes

FALTA PONER IMÁGENES Y RESULTADOS

## 6. Modificaciones del algoritmo

### 6.1 Modificación técnica selección de padres

Para modificar el algoritmo y comparar si existe una mejora en los resultados se han propuesto dos nuevas ténicas de selección de padres. 
En primer lugar, se ha implementado un método de selección totalmente aleatorio donde no se tendrá en cuenta el valor de fitness. 
En segundo lugar, se ha implementado la técnica de selección del muestreo universal estocástico (SUS) desarrollado por James Baker. Esta técnica es similar a la técnica de selección de la ruleta implementada anteriormente. Ambas técnicas utilizan los valores de fitness de los individuos para indicar la probabilidad de que salgan elegidos siendo la porción de la ruleta mayor en el indivduo con mejor fitness, sin embargo, la diferencia que existe entre ambas técnicas es que la técnica de la ruleta realiza *n* tiradas obteniendo cada vez un individuo y la técnica SUS únicamente realiza una tirada donde selecciona a todos los individuos mediante intervalos uniformente repartidos sobre la ruleta.

FALTA PONER RESULTADOS

### 6.2 Modificación operador de recombinación

Por otro lado, se ha propuesto un nuevo operador de recombinación. El operador anteriormente implementado elegía de forma aleatoria las clases que que pertenecían a un padre o al otro, sin embargo, este operador realiza la recombinación siempre del mismo modo, la primera mitad de clases serán de un padre y la segunda mitad del otro.

FALTA PONER RESULTADOS

$$
\textit{Formula} = 
  \sum_{\textit{i}=\textit{xxx}}^{\textit{yyy}}
  \frac
    {\textit{ZZZ}_{\textit{i}}}
    {\textit{MMM}_{i}^
      {\text{NN}_{\textit{i}}}
    }
$$